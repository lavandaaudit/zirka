<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>IBONIRIUM · Terrarium · EXP‑01 · Dynamic Geometric Star</title>

<style>
* { margin:0; padding:0; box-sizing:border-box; }
html, body {
  width:100%; height:100%;
  background:#000;
  overflow:hidden;
  font-family: monospace;
}
canvas { position:fixed; inset:0; }
#sensors{ position:fixed; left:0; right:0; bottom:0; height:140px; pointer-events:none; }
#info {
  position:fixed;
  bottom:12px; left:12px;
  color:#9affc2;
  font-size:12px;
  line-height:1.4;
  opacity:0.9;
}
#panel {
  position:fixed;
  bottom:12px; right:12px;
  max-width:360px;
  font-size:12px;
  color:#c7ffd9;
  line-height:1.45;
  background:linear-gradient(to left,rgba(0,0,0,0.6),transparent);
  padding:10px 14px;
}
</style>
</head>
<body>

<canvas id="stars"></canvas>
<canvas id="terrarium"></canvas>
<canvas id="sensors"></canvas>

<div id="info">
<b>IBONIRIUM · LAB TERRARIUM · EXP‑01</b><br>
Phase: <span id="phase">Growth</span><br>
Day: <span id="day">–</span><br>
Solar SSN: <span id="ssn">–</span><br>
Solar Factor: <span id="sf">–</span><br>
Star Energy: <span id="ge">–</span><br>
Target: 13 December
</div>

<div id="panel">
<b>СТАН ЕКСПЕРИМЕНТУ</b><br>
Геометрична зірка з хвилями енергії. Промені пульсують, обертаються та вигинаються відповідно до сонячної активності. <br><br>
До <b>13 грудня</b> накопичується енергія зірки. Форма і пульсація фіксуються у фінальній фазі.
</div>

<script>
/* ===== CANVAS ===== */
const starCanvas = document.getElementById('stars');
const tCanvas = document.getElementById('terrarium');
const sctx = starCanvas.getContext('2d');
const tctx = tCanvas.getContext('2d');
const sensorCanvas = document.getElementById('sensors');
const scx = sensorCanvas.getContext('2d');

function resize(){
  starCanvas.width = tCanvas.width = sensorCanvas.width = innerWidth;
  starCanvas.height = tCanvas.height = innerHeight;
  sensorCanvas.height = 140;
}
addEventListener('resize', resize); resize();

/* ===== STAR FIELD ===== */
const stars = Array.from({length:240},()=>({x:Math.random(),y:Math.random(),z:Math.random()}));
function drawStars(){
  sctx.clearRect(0,0,starCanvas.width,starCanvas.height);
  stars.forEach(st=>{
    st.y+=0.00025*(1+st.z);
    if(st.y>1) st.y=0;
    sctx.globalAlpha=0.3+st.z*0.6;
    sctx.fillStyle="#fff";
    sctx.beginPath();
    sctx.arc(st.x*starCanvas.width, st.y*starCanvas.height, st.z*1.4, 0, Math.PI*2);
    sctx.fill();
  });
  sctx.globalAlpha=1;
}

/* ===== ENV DATA ===== */
let solarFactor = 1;
let solarSSN = 0;
let starEnergy = 0;

/* ===== DYNAMIC GEOMETRIC STAR ===== */
class DynamicStar{
  constructor(x,y,points=7){
    this.x = x;
    this.y = y;
    this.points = points;
    this.innerRadius = 30;
    this.outerRadius = 70;
    this.angleOffset = 0;
  }
  
  update(){
    const time = Date.now();
    
    // обертання зірки
    this.angleOffset += 0.01 * solarFactor;
    
    // пульсація дихання
    this.outerRadius = 70 + Math.sin(time*0.002)*20*solarFactor;
    this.innerRadius = 30 + Math.sin(time*0.003 + 2)*10*solarFactor;
  }
  
  draw(){
    const time = Date.now();
    tctx.save();
    tctx.translate(this.x,this.y);
    tctx.rotate(this.angleOffset);
    
    // починаємо малювати хвилі променів
    tctx.beginPath();
    for(let i=0;i<this.points*2;i++){
      const angle = i*Math.PI/this.points;
      let r = (i%2===0)?this.outerRadius:this.innerRadius;
      
      // додамо хвилі енергії по амплітуді starEnergy
      r += Math.sin(time*0.005 + i)*10*starEnergy;
      
      const x = Math.cos(angle)*r;
      const y = Math.sin(angle)*r;
      if(i===0) tctx.moveTo(x,y);
      else tctx.lineTo(x,y);
    }
    tctx.closePath();
    
    // Gradient ядра і променів
    const gradient = tctx.createRadialGradient(0,0,this.innerRadius,0,0,this.outerRadius*1.2);
    gradient.addColorStop(0,'rgba(255,255,180,'+(0.9*solarFactor)+')');
    gradient.addColorStop(0.5,'rgba(255,160,80,'+(0.6*solarFactor)+')');
    gradient.addColorStop(1,'rgba(255,100,50,0)');
    tctx.fillStyle = gradient;
    tctx.fill();
    
    // контур для чіткої геометрії
    tctx.strokeStyle = `rgba(255,220,120,${0.5+0.3*Math.sin(time*0.005)})`;
    tctx.lineWidth = 2;
    tctx.stroke();
    
    tctx.restore();
  }
}

const star = new DynamicStar(tCanvas.width/2, tCanvas.height/2, 7);

/* ===== NOAA SOLAR API ===== */
async function updateSolar(){
  try{
    const r = await fetch('https://services.swpc.noaa.gov/json/solar-cycle/predicted-solar-cycle.json');
    const d = await r.json();
    const l = d[d.length-1];
    solarSSN = l.predicted_ssn;
    solarFactor = Math.min(3,0.6+solarSSN/120);
    starEnergy = solarFactor * (0.8+Math.random()*0.2);
    document.getElementById('ssn').textContent = solarSSN.toFixed(1);
    document.getElementById('sf').textContent = solarFactor.toFixed(2);
    document.getElementById('ge').textContent = starEnergy.toFixed(2);
  }catch(e){ solarFactor=1; starEnergy=1; }
}
updateSolar(); setInterval(updateSolar,1800000);

/* ===== SENSORS ===== */
function drawSensors(){
  scx.clearRect(0,0,sensorCanvas.width,sensorCanvas.height);
  const baseY = 110;

  scx.strokeStyle='rgba(120,255,180,0.25)';
  scx.beginPath(); scx.moveTo(0,baseY); scx.lineTo(sensorCanvas.width,baseY); scx.stroke();

  // solar sensor
  scx.fillStyle='rgba(255,200,120,0.8)';
  scx.beginPath();
  scx.arc(80, baseY-40, 10+solarFactor*3, 0, Math.PI*2);
  scx.fill();
  scx.fillText('☀ сонце', 50, baseY+20);

  // star energy meter
  scx.strokeStyle='rgba(255,220,100,0.8)';
  scx.beginPath();
  scx.moveTo(160, baseY);
  scx.lineTo(160, baseY-starEnergy*25);
  scx.stroke();
  scx.fillText('⭐ енергія', 140, baseY+20);

  // time sensor
  const now = new Date();
  const t = Math.min(1,(now-START_DATE)/(STOP_DATE-START_DATE));
  scx.strokeStyle='rgba(180,180,255,0.7)';
  scx.beginPath();
  scx.arc(260, baseY, 30, -Math.PI/2, -Math.PI/2 + t*Math.PI*2);
  scx.stroke();
  scx.fillText('⏳ цикл', 235, baseY+20);
}

/* ===== LOOP ===== */
const START_DATE = new Date('2026-01-01');
const STOP_DATE = new Date('2026-12-13');
function updateDay(){
  const now = new Date();
  const day = Math.floor((now-START_DATE)/(1000*60*60*24));
  document.getElementById('day').textContent = day>=0?day:0;
  document.getElementById('phase').textContent = now<STOP_DATE?'Growth':'Final';
}
setInterval(updateDay,60000);
updateDay();

function loop(){
  drawStars();
  drawSensors();
  if(new Date()<STOP_DATE){
    tctx.clearRect(0,0,tCanvas.width,tCanvas.height);
    star.update();
    star.draw();
  }
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
