<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>IBONIRIUM · 3D Cosmic Space Weather</title>
<style>
  body { margin:0; overflow:hidden; background:#0a0e14; }
  #info{
    position:absolute; top:16px; left:16px; font-family:monospace;
    color:#aaffcc; font-size:12px; line-height:1.4; text-shadow:0 0 3px #000;
    max-width:260px;
  }
  #info b{ color:#6fffa0; }
</style>
</head>
<body>
<div id="info">
  <div>Solar Wind Speed: <b><span id="wind">–</span> km/s</b></div>
  <div>Mag Field Bt: <b><span id="bt">–</span> nT</b></div>
  <div>Mag Field Bz: <b><span id="bz">–</span> nT</b></div>
  <div>K-index: <b><span id="kp">–</span></b></div>
  <div>NOAA R‑Scale: <b><span id="rscale">–</span></b></div>
  <div>NOAA S‑Scale: <b><span id="sscale">–</span></b></div>
  <div>NOAA G‑Scale: <b><span id="gscale">–</span></b></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r150/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/examples/js/controls/OrbitControls.js"></script>

<script>
let scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0a0e14, 0.025);

let camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 2000);
camera.position.set(0, 80, 220);

let renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x0a0e14);
document.body.appendChild(renderer.domElement);

let controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// ==========================
// 3D ЗІРКА
const count = 12000;
let geom = new THREE.BufferGeometry();
let pos = new Float32Array(count*3);
let col = new Float32Array(count*3);

for(let i=0; i<count; i++){
  const r = 35 + Math.random()*15;
  const theta = Math.random()*Math.PI*2;
  const phi = Math.acos(2*Math.random()-1);

  pos[3*i]   = r * Math.sin(phi)*Math.cos(theta);
  pos[3*i+1] = r * Math.sin(phi)*Math.sin(theta);
  pos[3*i+2] = r * Math.cos(phi);

  col[3*i]   = 0.9 + Math.random()*0.1;
  col[3*i+1] = 0.5 + Math.random()*0.4;
  col[3*i+2] = 1.0;
}

geom.setAttribute('position', new THREE.BufferAttribute(pos,3));
geom.setAttribute('color', new THREE.BufferAttribute(col,3));

let mat = new THREE.PointsMaterial({
  size: 2.2, vertexColors:true,
  transparent:true, opacity:0.9,
  depthWrite:false,
  blending: THREE.AdditiveBlending
});

let star = new THREE.Points(geom, mat);
scene.add(star);

let glow = new THREE.PointLight(0xffddaa, 1.0, 500);
scene.add(glow);

// ==========================
// Space Weather дані
let windSpeed=0, Bt=0, Bz=0, kp=0;
let Rscale="–", Sscale="–", Gscale="–";

async function updateSpaceWeather(){
  try{
    // 1) SWPC NOAA космічні API JSON
    // solar wind summary
    const sw = await fetch('https://services.swpc.noaa.gov/products/summary/solar-wind-speed.json');
    const swd = await sw.json();
    // магнітне поле
    const mag = await fetch('https://services.swpc.noaa.gov/products/summary/solar-wind-mag-field.json');
    const magd = await mag.json();
    // planetary kp
    const kpdat = await fetch('https://services.swpc.noaa.gov/products/noaa-planetary-k-index.json');
    const kpjson = await kpdat.json();
    // NOAA space weather scales
    const scales = await fetch('https://services.swpc.noaa.gov/products/noaa-scales.json');
    const scalesJson = await scales.json();

    // беремо останні записи
    windSpeed = parseFloat(swd.wind_speed || swd[swd.length-1].wind_speed||0);
    Bt = parseFloat(magd.Bt || magd[magd.length-1].Bt||0);
    Bz = parseFloat(magd.Bz || magd[magd.length-1].Bz||0);

    kp = parseFloat(kpjson[kpjson.length-1]?.kp || 0);

    const latestScale = scalesJson[ Object.keys(scalesJson).pop() ];
    Rscale = latestScale.R.Scale;
    Sscale = latestScale.S.Scale;
    Gscale = latestScale.G.Scale;

    document.getElementById('wind').textContent = windSpeed.toFixed(0);
    document.getElementById('bt').textContent = Bt.toFixed(1);
    document.getElementById('bz').textContent = Bz.toFixed(1);
    document.getElementById('kp').textContent = kp;
    document.getElementById('rscale').textContent = Rscale;
    document.getElementById('sscale').textContent = Sscale;
    document.getElementById('gscale').textContent = Gscale;
  }
  catch(e){ console.warn("Space weather fetch failed:",e); }
}

// початковий виклик і оновлення
updateSpaceWeather();
setInterval(updateSpaceWeather, 2*60*1000); // кожні 2 хв

// ==========================
function animate(){
  requestAnimationFrame(animate);
  const t = Date.now()*0.001;

  let arr = geom.attributes.position.array;
  for(let i=0; i<count; i++){
    arr[3*i]   += Math.sin(t + i*0.01) * 0.01 * (windSpeed/300+1);
    arr[3*i+1] += Math.cos(t + i*0.02) * 0.008;
  }
  geom.attributes.position.needsUpdate=true;

  // масштаб зірки залежить від KP індексу і solar wind
  const scale = 1 + kp/10 + windSpeed/1000;
  star.scale.set(scale, scale, scale);

  glow.intensity = 0.7 + kp/10 + Math.min(windSpeed/800,1);

  controls.update();
  renderer.render(scene,camera);
}
animate();

window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
