<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>IBONIRIUM · Terrarium · EXP‑01 · Star Simulation</title>

<style>
* { margin:0; padding:0; box-sizing:border-box; }
html, body {
  width:100%; height:100%;
  background:#000;
  overflow:hidden;
  font-family: monospace;
}
canvas { position:fixed; inset:0; }
#sensors{ position:fixed; left:0; right:0; bottom:0; height:140px; pointer-events:none; }
#info {
  position:fixed;
  bottom:12px; left:12px;
  color:#9affc2;
  font-size:12px;
  line-height:1.4;
  opacity:0.9;
}
#panel {
  position:fixed;
  bottom:12px; right:12px;
  max-width:360px;
  font-size:12px;
  color:#c7ffd9;
  line-height:1.45;
  background:linear-gradient(to left,rgba(0,0,0,0.6),transparent);
  padding:10px 14px;
}
</style>
</head>
<body>

<canvas id="stars"></canvas>
<canvas id="terrarium"></canvas>
<canvas id="sensors"></canvas>

<div id="info">
<b>IBONIRIUM · LAB TERRARIUM · EXP‑01</b><br>
Phase: <span id="phase">Growth</span><br>
Day: <span id="day">–</span><br>
Solar SSN: <span id="ssn">–</span><br>
Solar Factor: <span id="sf">–</span><br>
Star Energy: <span id="ge">–</span><br>
Target: 13 December
</div>

<div id="panel">
<b>СТАН ЕКСПЕРИМЕНТУ</b><br>
Це живий космічний експеримент. Зірка пульсує та реагує на реальні сонячні дані NOAA. Швидкість пульсації, розмір променів та світіння залежать від сонячної активності. <br><br>
До <b>13 грудня</b> накопичується енергія зірки. У цей день експеримент переходить у фінальну фазу: пульсація стабілізується, стан фіксується.
</div>

<script>
/* ===== CANVAS ===== */
const starCanvas = document.getElementById('stars');
const tCanvas = document.getElementById('terrarium');
const sctx = starCanvas.getContext('2d');
const tctx = tCanvas.getContext('2d');
const sensorCanvas = document.getElementById('sensors');
const scx = sensorCanvas.getContext('2d');

function resize(){
  starCanvas.width = tCanvas.width = sensorCanvas.width = innerWidth;
  starCanvas.height = tCanvas.height = innerHeight;
  sensorCanvas.height = 140;
}
addEventListener('resize', resize); resize();

/* ===== STAR FIELD ===== */
const stars = Array.from({length:240},()=>({x:Math.random(),y:Math.random(),z:Math.random()}));
function drawStars(){
  sctx.clearRect(0,0,starCanvas.width,starCanvas.height);
  stars.forEach(st=>{
    st.y+=0.00025*(1+st.z);
    if(st.y>1) st.y=0;
    sctx.globalAlpha=0.3+st.z*0.6;
    sctx.fillStyle="#fff";
    sctx.beginPath();
    sctx.arc(st.x*starCanvas.width, st.y*starCanvas.height, st.z*1.4, 0, Math.PI*2);
    sctx.fill();
  });
  sctx.globalAlpha=1;
}

/* ===== SIMPLE NOISE ===== */
function noise(x,y){
  return Math.sin(x*12.989+y*78.233)*43758.5453%1;
}

/* ===== ENV DATA ===== */
let solarFactor = 1;
let solarSSN = 0;
let starEnergy = 0;

/* ===== STAR SIMULATION ===== */
class Star{
  constructor(x, y){
    this.x = x;
    this.y = y;
    this.radius = 50 + Math.random()*20;
    this.pulse = Math.random()*Math.PI*2;
    this.beams = Array.from({length:16},()=>Math.random()*Math.PI*2);
  }
  
  update(){
    this.pulse += 0.05 * solarFactor;
  }
  
  draw(){
    const glow = Math.sin(this.pulse)*10*solarFactor;
    const radius = this.radius + glow;
    
    // core glow
    const gradient = tctx.createRadialGradient(this.x, this.y, radius*0.2, this.x, this.y, radius);
    gradient.addColorStop(0,'rgba(255,255,200,'+(0.8*solarFactor)+')');
    gradient.addColorStop(0.5,'rgba(255,180,100,'+(0.5*solarFactor)+')');
    gradient.addColorStop(1,'rgba(255,100,50,0)');
    tctx.fillStyle = gradient;
    tctx.beginPath();
    tctx.arc(this.x, this.y, radius,0,Math.PI*2);
    tctx.fill();
    
    // beams
    this.beams.forEach((angle,i)=>{
      const length = radius*1.5 + Math.sin(Date.now()*0.002 + i)*15*solarFactor;
      tctx.strokeStyle=`rgba(255,220,120,${0.2+0.3*Math.random()})`;
      tctx.lineWidth=1.5;
      tctx.beginPath();
      tctx.moveTo(this.x, this.y);
      tctx.lineTo(this.x + Math.cos(angle)*length, this.y + Math.sin(angle)*length);
      tctx.stroke();
    });
  }
}

const star = new Star(tCanvas.width/2, tCanvas.height/2);

/* ===== NOAA SOLAR API ===== */
async function updateSolar(){
  try{
    const r = await fetch('https://services.swpc.noaa.gov/json/solar-cycle/predicted-solar-cycle.json');
    const d = await r.json();
    const l = d[d.length-1];
    solarSSN = l.predicted_ssn;
    solarFactor = Math.min(3,0.6+solarSSN/120);
    starEnergy = solarFactor * (0.8+Math.random()*0.2);
    document.getElementById('ssn').textContent = solarSSN.toFixed(1);
    document.getElementById('sf').textContent = solarFactor.toFixed(2);
    document.getElementById('ge').textContent = starEnergy.toFixed(2);
  }catch(e){ solarFactor=1; starEnergy=1; }
}
updateSolar(); setInterval(updateSolar,1800000);

/* ===== SENSORS ===== */
function drawSensors(){
  scx.clearRect(0,0,sensorCanvas.width,sensorCanvas.height);
  const baseY = 110;

  // ground line
  scx.strokeStyle='rgba(120,255,180,0.25)';
  scx.beginPath(); scx.moveTo(0,baseY); scx.lineTo(sensorCanvas.width,baseY); scx.stroke();

  // solar sensor
  scx.fillStyle='rgba(255,200,120,0.8)';
  scx.beginPath();
  scx.arc(80, baseY-40, 10+solarFactor*3, 0, Math.PI*2);
  scx.fill();
  scx.fillText('☀ сонце', 50, baseY+20);

  // star energy meter
  scx.strokeStyle='rgba(255,220,100,0.8)';
  scx.beginPath();
  scx.moveTo(160, baseY);
  scx.lineTo(160, baseY-starEnergy*25);
  scx.stroke();
  scx.fillText('⭐ енергія', 140, baseY+20);

  // time sensor
  const now = new Date();
  const t = Math.min(1,(now-START_DATE)/(STOP_DATE-START_DATE));
  scx.strokeStyle='rgba(180,180,255,0.7)';
  scx.beginPath();
  scx.arc(260, baseY, 30, -Math.PI/2, -Math.PI/2 + t*Math.PI*2);
  scx.stroke();
  scx.fillText('⏳ цикл', 235, baseY+20);
}

/* ===== LOOP ===== */
const START_DATE = new Date('2026-01-01');
const STOP_DATE = new Date('2026-12-13');
function updateDay(){
  const now = new Date();
  const day = Math.floor((now-START_DATE)/(1000*60*60*24));
  document.getElementById('day').textContent = day>=0?day:0;
  document.getElementById('phase').textContent = now<STOP_DATE?'Growth':'Final';
}
setInterval(updateDay,60000);
updateDay();

function loop(){
  drawStars();
  drawSensors();
  if(new Date()<STOP_DATE){
    tctx.clearRect(0,0,tCanvas.width,tCanvas.height);
    star.update();
    star.draw();
  }
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
